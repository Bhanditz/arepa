#!/usr/bin/perl

use strict;
use warnings;
use English qw(-no_match_vars);
use Carp;
use Getopt::Long;

use Arepa::BuilderFarm;
use Arepa::Repository;

sub sign_distribution {
    my ($config, $distro_name) = @_;

    my $repo_path = $config->get_key('repository:path');
    my $release_file_path = File::Spec->catfile($repo_path,
                                                "dists",
                                                $distro_name,
                                                "Release");
    unlink "$release_file_path.gpg";

    my $extra_options = "";
    if ($config->key_exists('repository:signature:id')) {
        my $key_id = $config->get_key('repository:signature:id');
        $extra_options = " -u $key_id";
    }
    my $gpg_cmd = "gpg --batch -abs $extra_options -o $release_file_path.gpg $release_file_path &>/dev/null";

    return (system($gpg_cmd) == 0);
}

my ($r);
my $config_file = '/etc/arepa/config.yml';

Getopt::Long::Configure('pass_through');
$r = GetOptions('config|c=s', \$config_file);
if (!$r) {
    print STDERR "Invalid global options\n";
    exit 1;
}

my $command = shift || do {
    print STDERR "ERROR: I need a command\n";
    print STDERR "SYNTAX: arepa [-c|--config=config.yml] <command> [options]\n";
    print STDERR "where <command> is one of:\n";
    print STDERR "  build\n";
    print STDERR "  queue\n";
    print STDERR "  requeue\n";
    print STDERR "  showqueue\n";
    print STDERR "  sign\n";
    print STDERR "  sync\n";
    exit 1;
};

my $config     = Arepa::Config->new($config_file);

if ($command eq 'build') {
    my ($pending, $recompile) = (0, undef);
    $r = GetOptions('pending'     => \$pending,
                    'recompile=i' => \$recompile);
    if (!$r) {
        print STDERR "Invalid options for build command\n";
        exit 1;
    }

    my $farm       = Arepa::BuilderFarm->new($config_file);
    my $repository = Arepa::Repository->new($config_file);
    if ($pending) {
        foreach my $req ($farm->package_db->get_compilation_queue(status => 'pending')) {
            # Just get the first one if there are multiple matches
            my ($builder) = $farm->get_matching_builders($req->{architecture},
                                                         $req->{distribution});
            if (!defined $builder) {
                print STDERR "Goddamnit! There aren't any builders for $req->{distribution}/$req->{architecture}\n";
                exit 1;
            }
            my $source_pkg_id = $req->{source_package_id};
            my %source_attrs  = $farm->package_db->get_source_package_by_id($source_pkg_id);
            print "Compiling request id $req->{id}\n";
            print "$source_attrs{name} $source_attrs{full_version} ";
            print "(arch: $req->{architecture}, ";
            print "distro: $req->{distribution}) ";
            print "with builder $builder...\n";
            if ($farm->compile_package_from_queue($builder, $req->{id})) {
                print "*** SUCCESS ***\n";
                foreach my $deb_package (glob('*.deb')) {
                    print "Adding $deb_package to the repository\n";
                    if ($repository->insert_binary_package($deb_package,
                                                           $req->{distribution})) {
                        unlink $deb_package;
                        sign_distribution($config, $req->{distribution});
                    }
                }
            }
            else {
                print "*** FAILED ***\n";
            }
        }
    }
    elsif (defined $recompile) {
        my %req = $farm->package_db->get_compilation_request_by_id($recompile);

        # Find out the builder for this compilation. If it's not claimed by any
        # builder, get the first matching (there should be only one, really)
        my $builder = $req{builder};
        if (!$builder) {
            ($builder) = $farm->get_matching_builders($req{architecture},
                                                      $req{distribution});
        }

        my %source_attrs  = $farm->package_db->get_source_package_by_id($req{source_package_id});
        print "Compiling request id $req{id}\n";
        print "$source_attrs{name} $source_attrs{full_version} ";
        print "(arch: $req{architecture}, ";
        print "distro: $req{distribution}) ";
        print "with builder $builder...\n";
        if ($farm->compile_package_from_queue($builder, $req{id})) {
            print " done.\n";
            foreach my $deb_package (glob('*.deb')) {
                print "Adding $deb_package to the repository\n";
                if ($repository->insert_binary_package($deb_package,
                                                       $req{distribution})) {
                    unlink $deb_package;
                    sign_distribution($config, $req{distribution});
                }
            }
        }
        else {
            print " failed.\n";
            print "Log:\n", $farm->last_build_log, "\n";
        }
    }
    else {
        my ($dsc_file, $builder) = @ARGV;
        if (!defined $dsc_file || !defined $builder) {
            print STDERR "ERROR: Need a dsc file and a builder name\n";
            exit 1;
        }
        $farm->compile_package_from_dsc($builder, $dsc_file,
                                        output_dir => '.');
        foreach my $deb_package (glob('*.deb')) {
            print "Adding $deb_package to the repository\n";
            if ($repository->insert_binary_package($deb_package)) {
                unlink $deb_package;
            }
        }
    }
}
elsif ($command eq 'queue') {
    my ($dsc_file, $distro) = @ARGV;
    if (!defined $dsc_file) {
        print STDERR "I need a dsc_file to queue\n";
        exit 1;
    }
    $distro ||= 'unstable';

    my $farm = Arepa::BuilderFarm->new($config_file);
    my %source_attrs = (distribution => $distro);
    open F, $dsc_file or croak("Can't open dsc file '$dsc_file'");
    while (my $line = <F>) {
        if ($line =~ /^Source: (.+)/) {
            $source_attrs{name} ||= $1;
        }
        elsif ($line =~ /^Architecture: (.+)/) {
            $source_attrs{architecture} ||= $1;
        }
        elsif ($line =~ /^Version: (.+)/) {
            $source_attrs{full_version} ||= $1;
        }
    }
    close F;

    print "Source package: $source_attrs{name} $source_attrs{full_version} ";
    print "(arch: $source_attrs{architecture}, ";
    print "distribution: $source_attrs{distribution})\n";

    # Queue the source package for compilation
    my $source_id = $farm->register_source_package(%source_attrs);
    $farm->request_package_compilation($source_id);
}
elsif ($command eq 'requeue') {
    my ($queue_id) = @ARGV;
    if (!defined $queue_id) {
        print STDERR "I need a queue id to requeue\n";
        exit 1;
    }
    my $pdb    = Arepa::PackageDb->new($config->get_key('package_db'));
    my %compilation_attrs = ();
    eval {
        %compilation_attrs = $pdb->get_compilation_request_by_id($queue_id);
    };
    if ($EVAL_ERROR) {
        print STDERR "Can't find compilation request '$queue_id'\n";
        print STDERR "Check with arepa showqueue\n";
        exit 1;
    }
    $pdb->mark_compilation_pending($queue_id);
}
elsif ($command eq 'showqueue') {
    my $status = 'pending';
    $r = GetOptions('status=s'     => \$status);
    if (!$r) {
        print STDERR "Invalid options for 'showqueue' command\n";
        exit 1;
    }
    my $pdb    = Arepa::PackageDb->new($config->get_key('package_db'));
    foreach my $elt ($pdb->get_compilation_queue(status => $status)) {
        my %source = $pdb->get_source_package_by_id($elt->{source_package_id});
        print $elt->{id}, ": $source{name} $source{full_version} ";
        print "$elt->{architecture} $elt->{distribution}\n";
    }
}
elsif ($command eq 'sign') {
    my $sync = 0;
    $r = GetOptions('sync' => \$sync);
    if (!$r) {
        print STDERR "Invalid options for 'sign' command\n";
        exit 1;
    }

    my $repo_path = $config->get_key('repository:path');

    # Sign all the Release files
    my $repository = Arepa::Repository->new($config_file);
    foreach my $distribution ($repository->get_distributions) {
        my $distro_name = $distribution->{codename};
        print "Signing $distro_name...\n";
        if (! sign_distribution($config, $distro_name)) {
            print STDERR "ERROR: couldn't sign Release file for '$distro_name'\n";
            exit 1;
        }
    }

    # If --sync was passed, sync too
    if ($sync) {
        my $remote_repo_path = $config->get_key('repository:remote_path');
        my $rsync_cmd = "rsync -avz --delete $repo_path $remote_repo_path";
        if (system($rsync_cmd) != 0) {
            print STDERR "ERROR: rsync command failed\n";
            print STDERR "Command was '$rsync_cmd'\n";
        }
    }
}
elsif ($command eq 'sync') {
    my $local_repo  = $config->get_key('repository:path');
    my $remote_repo = $config->get_key('repository:remote_path');
    my $rsync_cmd = "rsync -avz --delete $local_repo $remote_repo";
    if (system($rsync_cmd) != 0) {
        print STDERR "ERROR: rsync command failed\n";
        print STDERR "Command was '$rsync_cmd'\n";
    }
}
else {
    print STDERR "ERROR: Unknown command '$command'\n";
    exit 1;
}

__END__
arepa build --pending       # Process build queue
arepa build <file.dsc>      # Builds the given .dsc in all relevant builders
arepa build <file.dsc> <builder_name>
arepa queue <file.dsc>
arepa queue <file.dsc> <arch>
arepa unqueue <file.dsc>
arepa unqueue <file.dsc> <arch>
arepa showqueue
